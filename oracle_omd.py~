'''
~~~~~~~
NOTES:
~~~~~~~
-> f divides into two sub-networks:
   - Encoder E and classifier C
      ~ E: X->Z, where X is image space, Z is latent space.
         i) Z is a vector space R^d
      ~ C: Z->\delta_K, where \delta_K is the probability simplex
        over the K known classes.

-> Open category detector g:X->[0,1] will be divided into the same
Encoder E and scoring function S, where S:Z->[0,1].
    - So, the classifier f and the open category detector g share
    the same latent space Z (Presumably will be generated by
    Autoencoders)

-> Learning a good anomaly detector g is thus decomposed into the
problem of learning a good latent representation Z=E(X) and a good
scoring function S.

~~~~~~~~~~~~~~~~~~~~~~~
PROCESS AT HIGH LEVEL:
~~~~~~~~~~~~~~~~~~~~~~~
Given test query x, eval g(x) and compare it to an anomaly score
threshold \tao (0.5). If g(x) >= \tao, x is declared to belong
to an unknown class, and an appropriate action, such as raising an
alarm, is taken.

Otherwise, closed-world classifier f is applied to predict a
probability distribution over the known classes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ORACLE REPRESENTATION LEARNING:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-> To obtain oracle latent representation, train network f on
all classes (known and unknown).

'''

import matplotlib.pyplot as plt
import numpy as np
import torch
import torchvision
import pandas as pd
import os
import json


def main():
    # Load known and unknown classes (*a is known *b is unknown)
    # binary or multiclass category detector??
    pass

if __name__ == '__main__':
    main()
