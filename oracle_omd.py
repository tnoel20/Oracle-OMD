'''
~~~~~~~
NOTES:
~~~~~~~
-> f divides into two sub-networks:
   - Encoder E and classifier C
      ~ E: X->Z, where X is image space, Z is latent space.
         i) Z is a vector space R^d
      ~ C: Z->\delta_K, where \delta_K is the probability simplex
        over the K known classes.

-> Open category detector g:X->[0,1] will be divided into the same
Encoder E and scoring function S, where S:Z->[0,1].
    - So, the classifier f and the open category detector g share
    the same latent space Z (Presumably will be generated by
    Autoencoders)

-> Learning a good anomaly detector g is thus decomposed into the
problem of learning a good latent representation Z=E(X) and a good
scoring function S.

~~~~~~~~~~~~~~~~~~~~~~~
PROCESS AT HIGH LEVEL:
~~~~~~~~~~~~~~~~~~~~~~~
Given test query x, eval g(x) and compare it to an anomaly score
threshold \tao (0.5). If g(x) >= \tao, x is declared to belong
to an unknown class, and an appropriate action, such as raising an
alarm, is taken.

Otherwise, closed-world classifier f is applied to predict a
probability distribution over the known classes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ORACLE REPRESENTATION LEARNING:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-> To obtain oracle latent representation, train network f on
all classes (known and unknown).

'''

import matplotlib.pyplot as plt
import numpy as np
import torch
import torchvision
import pandas as pd
import os
import json

def load_known_unknown(split_num=0):
    ''' 
    Known/Unknown split semantics can be found in download_cifar10.py
    in the following git repo:
    https://github.com/lwneal/counterfactual-open-set

    I use a modified download script to produce the files that I'm
    loading here via Pandas: download_cifar10_to_csv.py
    '''
    

def main():
    # Load known and unknown classes (*a is known *b is unknown)
    known, unknown = load_known_unknown()
    # binary or multiclass category detector??
    pass

if __name__ == '__main__':
    main()
